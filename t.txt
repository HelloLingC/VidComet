This is a 3.
It's sloppily written and rendered at an extremely low resolution of 28x28 pixels, but your brain has no trouble recognizing it as a 3.
And I want you to take a moment to appreciate how crazy it is
that brains can do this effortlessly.
I mean this, this, this, this, this, and this are also recognizable as 3s, even though the specific values of each pixel is very different from one image to the next.
The particular light-sensitive cells in your eye that are firing
when you see these three are very different from the ones firing when you see three.
But something in that crazy smart visual cortex of yours resolves these as representing the same idea, while at the same time recognizing the same idea, while at the same time recognizing the same idea, while recognizing the same idea, while recognizing the same idea, while recognizing the same idea, while recognizing the same idea, while recognizing the same idea, while recognizing the same idea, while recognizing the same idea, while recognizing other images as their own distinct idea.
But if I told you, hey, sit down and write for me a program that takes in a grid of 28x28 pixels like this, and outputs a single number between 0 and 10, telling you what it thinks the digit is?
Well, the task goes from comically trivial to dauntingly difficult.
Unless you've been living under a rock, I think I hardly need to motivate the relevance
and importance of machine learning
and neural networks to the present and future.
But what I want to show you what a neural network actually is, assuming no background.
I think I hardly need to motivate the relevance
and importance of machine learning and learning.
I think I hardly need to motivate the relevance
and importance of machine learning and learning.
But what I want to show you what a neural network actually is, assuming no background, assuming no background, and to help visualize what a neural network is doing.
Not as a buzzword, but as a piece of math.
My hope is just that you come away feeling like the structure itself is motivated
and to feel like you know what it means
when you read or hear about a neural network quote unquote learning.
This video is just going to be devoted to the structure component, and the following one is going to tackle learning.
What we're going to put together a neural network that can learn to recognize handwritten digits.
This is a somewhat classic example for introducing the topic
and I'm happy to stick with the status quo here
because at the end of the two videos I want to point you to a couple good resources
where you can learn more
and download the code that does this
and play with it on your computer.
There are many, many variants of neural networks, and in recent years there's been sort of a boom in research towards these variants.
But in these two introductory videos, you and I will just look at the simplest plain vanilla form with no added frills.
This is a necessary prerequisite for understanding of any more powerful variants, but in these two introductory videos, you and I will just look at the simplest plain vanilla form with no added frills.
This is a necessary prerequisite for understanding of any more powerful modern variants, and trust me, it still has plenty of complexity for us to wrap our minds around.
But even in this simplest form, it can learn to recognize handwritten digits, which is a pretty cool thing for a computer to be able to do.
And at the same time, you'll see how it does fall short of a couple hopes that we might have for it.
As the name suggests, it can learn to recognize handwritten digits, which is a pretty cool thing for a computer to be able to do.
And at the same time, you'll see how it does fall short of a couple hopes that we might have for it.
As the name suggests, neural networks are inspired by the brain.
But let's break that down.
What are the neurons and in what sense are they linked together?
Right now, when I say neuron, all I want you to think about is a thing that holds a number.
Specifically, a number between 0 and 1.
It's really not more than that.
For example, the network starts with a bunch of neurons corresponding to each of the 28x28x28 pixels of the input image, which is 784 neurons in total.
Each one of these holds a number that represents the grays of the grays of the grays of the grays of the grays of grays of the grays of grays of grays of grays of grays of grays of grays of grays of grays of grays of grays of grays of grays of grays of grays of grays of grays of grays.
This number inside the neuron is called its activation.
The image you might have in mind here is
that each neuron is lit up
when its activation is a high number.
So all of these 784 neurons make up the first layer of our network.
Now jumping over to the last layer, this has 10 neurons each representing one of the digits.
The activation in these neurons, again, some number that's between 0 and 1, represents how much the system thinks
that a given image corresponds with a given digit.
There's also a couple layers in between, called the hidden layers, which should be a giant question mark for how on earth this process of recognizing.
In this network, I chose two hidden layers, each one with 16 neurons, and admittedly, that's kind of an arbitrary choice.
To be honest, I chose two layers based on how I want to motivate the structure in just a moment.
And 16?
Well, that was just a nice number to fit on the screen.
In practice, there is a lot of room for experiment with a specific structure.
The way the network operates, the way the network operates.
Activations in one layer determine the activations of the next layer.
And of course, the heart of the network, as an information processing mechanism, comes down to exactly how those activations from one layer bring about activations in the next layer.
It's meant to be loosely analogous to how in biological networks of neurons, some groups of neurons firing, cause certain others to fire.
Now, the network I'm showing here has already been trained to recognize digits, and let me show you what I mean by that.
It means if you feed in an image lighting up all 784 neurons of the input layer, according to the brightness of each pixel in the image.
That pattern of activations causes some very specific pattern in the next layer, which causes some pattern in the one after it, which finally gives some pattern in the output layer.
And the brightest neuron of that output layer is the network's choice, so to speak, for what digit this image represents.
And before jumping into the math for how one layer influences influences the next, or how training works.
Let's just talk about why it's even if it's choice for what digit this image represents.
And before jumping into the math for how one layer influences the next, or how training works.
Let's just talk about why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's why it's
Well, when you or I recognize digits, we piece together various components.
A 9 has a loop up top
and a line on the right.
An 8 also has a loop up top, but it's paired with another loop down low.
A 4 basically breaks down into three specific lines and things like that.
Now, in a perfect world, we might hope that each neuron in the second-to-last layer corresponds with one of these subcomponents.
That any time you feed in an image with a loop up top, like a 9 or 8, there's some specific neuron whose activation is close to 1.
And I don't mean this specific loop of pixels.
The hope would be that any loopy loopy pattern sets off this neuron.
That way, going from the third layer to the last layer just requires learning which combination of subcomponents corresponds to which digits.
Recognizing a loop can also break down into subproblems.
One reasonable way to do this would be to first recognize the various little edges that make it up.
Similarly, a long line, like the kind you might see in the digits 1, or 4, or 7, well that's really just a long edge.
Or maybe you think of it as a certain pattern of several smaller edges.
So maybe our hope is that each neuron in the second layer of the second layer of the network.
Maybe, when an image like this one comes in, it lights up all of the neurons associated with around 8-10 specific little edges, which in turn lights up the neurons associated with the upper loop and a long vertical line, and those light up the neurons associated with a 9.
Whether or not this is what our final network actually does, which light up the neurons associated with around 8 to 10 specific little edges, which in turn lights up the neurons associated with the upper loop and a long vertical line, and those light up the neurons associated with a 9.
Whether or not this is what our final network actually does is another question, one that I'll come back to once we see how to train the network, but this is a hope that we might have, a sort of goal with a layered structure like this.
Moreover, you can imagine how being able to detect edges
and patterns like this would be really useful for other image recognition tasks.
And even beyond image recognition, there are all sorts of intelligent things that break down into layers of abstraction.
But getting back to how any of this actually works, picture yourself right now designing how exactly the activations in one layer might determine the activations in the next.
The goal is to have some mechanism that could conceivably combine pixels into edges, or edges into patterns, or patterns into digits.
And to zoom in on one very specific example, let's the hope is for one particular neuron in the second layer in the second layer to pick up on whether the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image of the image.
The question at hand is, what parameters should the network have?
What dials and knobs should you be able to tweak so that it's expressive enough to capture this pattern, or any other pixel pattern, or the pattern that several edges can make a loop?
What dials and knobs should you be able to tweak so that it's expressive enough to capture this pattern, or any other pixel pattern, or any pixel pattern, or any pixel pattern, or the pattern that several edges can make a loop.
Well, what we'll do is assign a weight to each one of the connections between our neuron
and the neurons from the first layer.
These weights are just numbers.
Then, take all of those activations from the first layer
and compute their weighted sum according to these weights.
I find it helpful to think of these weights as being organized into a grid of their own.
I'm going to use green pixels to indicate positive
and red pixels to indicate negative weights, where the brightness of that pixel is some loose depiction of the weight's value.
Now, if we made the weights associated with almost all of the pixels zero, except for some positive weights in this region that we care about, then taking the weighted sum of all the pixel values really just amounts to adding up the values of the pixel values just in the region that we care about.
And if you really wanted to pick up on whether there's an edge here, what you might do is have negative weights associated with the surrounding pixels.
When you compute a weighted sum like this, you might come out with any number.
But for this network, what we want is for some value between 0 and 1.
And a common function that does this is called the sigmoid function, also known as a logistic curve.
Basically, very negative inputs end up close to zero, very positive inputs end up close to one, and it just steadily increases around the input zero.
So the activation of the neuron here is basically a measure of how positive the relevant weighted sum is.
But maybe it's not
that you want the neuron to light up
when the weighted sum is bigger than 0.
Maybe you only want it to be active
when the sum is bigger than, say, 10.
That is, you want some bias for it to be inactive.
What we'll do then is just add in some other number, like negative 10 to this weighted sum before plugging it through the sigmoid squish function.
That additional number is called the bias.
So the weights tell you what pixel pattern this neuron in the second layer is picking up on, and the bias tells you how high the weighted sum needs to be before the neuron starts getting meaning.
And that is just one neuron.
Every other neuron in this layer is going to be connected to all 784 pixel neurons from the first layer.
And that is just one neuron.
Every neuron in this layer is going to be connected to all 784 pixel neurons from the first layer.
And that is just one neuron.
Every neuron in this layer is going to be connected to all 784 pixel neurons from the first layer.
And each one of those 784 connections has its own weight associated with it.
Also, each one has some bias, some other number that you add on to the weighted sum before squishing it with the sigmoid.
And that's a lot to think about!
With this hidden layer of 16 neurons, that's a total of 784 x16 weights, along with 16 biases.
And all of that is just the connections from the first layer to the second layer.
And that's a lot to think about!
With this hidden layer of 16 neurons, that's a total of 784 times 16 weights, along with 16 biases.
And all of that is just the connections from the first layer to the second layer.
The connections between the other layers also have a bunch of weights and biases associated with them.
All said and done,
This network has almost exactly 13,000 total weights and biases.
13,000 knobs and dials that can be tweaked
and turned to make this network behave in different ways.
One thought experiment that is at once fun and kind of horrifying, is to imagine sitting down
and setting all of these weights and biases by hand, purposefully tweaking the numbers so
that the second layer picks up on edges, the third layer picks up on edges, etc.
I personally find this satisfying, rather than just treating the weights and biases by hand, purposefully tweaking the weights and biases by hand, purposefully tweaking the numbers so
that the second layer picks up on edges, the third layer picks up on edges, etc.
I personally find this satisfying, rather than just treating the network as a total black box, because when the network doesn't perform the way you anticipate, if you've built up a little bit of a relationship with what those weights and biases actually mean,
So let me show you a more notationally compact way that these connections are represented.
This is how you'd see it if you choose to read up more about neural networks.
What that means is that taking the weighted sum of the activations in the first layer, according to these weights, corresponds to one of the matrix vector product of everything we have on the left here.
By the weighted sum of the activations in the first layer, corresponds to one of the matrix vector vector.
By the weighted sum of the weighted sum of the activations in the first layer.
By the way, so much of machine learning just comes down to having a good grasp of linear algebra.
So for any of you who want a nice visual understanding of matrices
and what matrix vector multiplication means, take a look at the series I did on linear algebra.
especially chapter 3.
Back to our expression, instead of adding the bias to each one of these values independently, we represent it by organizing all those biases into a vector, and adding the entire vector to the previous matrix vector product.
Then as a final step, I'll wrap a sigmoid around the outside here, we represent it by organizing it by organizing all those biases into a vector, and adding the entire vector.
Then as a final step, I'll wrap a sigmoid around the outside here.
And what that's supposed to represent is
that you're going to apply the sigmoid function to each component of the resulting vector inside.
Remember how earlier I said these neurons are simply things that hold numbers
Well, of course, the specific numbers that they hold depends on the image you feed in.
So it's actually more accurate to think of each neuron as a function, one that takes in the outputs of all the neurons in the previous layer, and spits out a number between 0 and 1.
Really, it's more accurate to think of each neuron as a function, one that takes in the outputs of all the neurons in the neurons of all the neurons in the neurons.
It's an absurdly complicated function, one that involves 13,000 parameters in the form of these weights
and biases that pick up on certain patterns, and which involves iterating many matrix vector products and the sigmoid squishification function, but it's just a function, but it's just a function, but it's just a function, but it's just a function, but it's just a function, but it's just a function, but it's just a function, but it's just a function, but it's just a function, but it's just a function, but it's just a function, but it's just a function, but it's just a function, but it's just a function, and in a way, it's kind of reassuring that it looks complicated.
I mean, if it were any simpler, what hope would we have
that it could take on the challenge of recognizing digits?
And how does it take on that challenge?
How does this network learn the appropriate weights
and biases just by looking at data?
Well, that's what I'll show in the next video.
Maybe more honestly, I should say subscribe so
that the neural networks that underlie YouTube's recommendation algorithm are primed to believe
that you want to see content from this channel get recommended to you.
Anyway, stay posted for more.
Thank you very much.
Thank you very much.
Thank you very much to everyone supporting these videos on Patreon.
Thank you very much.
Thank you very much.
Thank you very much.
Thank you very much.
Thank you very much.
Thank you very much.
Thank you very much.
Thank you very much.
Thank you very much.
Thank you very much to everyone supporting these videos on Patreon.
I've been a little slow to progress in the probability series this summer, but I'm jumping back into it after this project, so patrons you can look out for updates there.
To close things off here, I have with me Leisha Lee, who did her PhD work on the theoretical side of deep learning, and who currently works at a venture capital firm called Amplify Partners, who kindly provided some funding for this video.
So, Leisha, one thing I think we should quickly bring up is this sigmoid function.
And RELU stands for Rectified Linear Unit?
Yes, it's this kind of function
where you're just taking a max of zero and A, where A is given by what you were explaining in the video.
And what this was sort of what you're doing.
All right.
Thank you, Alicia.